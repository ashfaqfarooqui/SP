package sp.supremicaStuff.exploring

import sp.supremicaStuff.base.{ StateTransExplorer, NamingInAutogeneratedFlowers }
import sp.supremicaStuff.base.TextFilePrefix

trait StateTransExploring extends StateTransExplorer {
  case class Transition(label: String, actionEval: State => State) {
    override def toString = label
  }
  implicit def transOrdering: Ordering[Transition] = {
    def transToStrWithoutUcPrefix: Transition => String = _.label.replaceAll(TextFilePrefix.UNCONTROLLABLE_PREFIX, "")
    Ordering.fromLessThan(transToStrWithoutUcPrefix(_) < transToStrWithoutUcPrefix(_))
  }
  case class StateTrans(state: State, trans: Transition)
  var stateTransSeq: Seq[StateTrans] = Seq() //To store selected trans, and states inbetween
  var previousState: Option[State] = None
  def activeState = if (stateTransSeq.isEmpty) initState else stateTransSeq.last.trans.actionEval(stateTransSeq.last.state)
  def activeTransitions = getTsEnabledFromSpecificState(activeState).map { case (k, v) => Transition(k, v) }.toSeq sorted

  private def printSelection = {
    //State=variables with value. Variables for forbidden values combinations removed. Ignores first letter in each variable name.
    val tempState = (unmaskState(activeState).filterKeys(!_.startsWith(NamingInAutogeneratedFlowers.FORBIDDEN_VARIABLE_NAME)).toSeq sorted).map { case (n, v) => n.substring(1) -> v }
    val longestNameLength = (tempState.unzip._1.map(_.length()) sorted).last
    val longestValueLength = (tempState.unzip._2.map(_.length()) sorted).last
    val intersectingSubState = getIntersectionSubState(activeState, previousState.getOrElse(Map())).unzip._1.map(_.substring(1).toUpperCase()).toSet

    val tempStateStrings = tempState.map { case (n, v) => (n.toUpperCase(), v) }.map {
      case (n, v) =>
        //name   :value   <
        s"$n:${" " * (longestNameLength - n.length())}$v${" " * (longestValueLength - v.length())}${if (!intersectingSubState.contains(n)) " <" else ""}"
    }
    println(tempStateStrings.mkString("\n", "\n", ""))

    //initial / marked
    if (activeState.equals(initState)) println("<<INITIAL STATE>>")
    if (isStateMarked(activeState)) println("<<MARKED STATE>>")

    //sugar
    println("-" * (longestNameLength + ":".length() + longestValueLength))

    //Transitions enabled from active state + index. Undo-selection added in order to return to previous active state.
    println(s"${activeTransitions.zipWithIndex.map { case (t, i) => s"$i:$t" }.mkString("\n")}${if (!stateTransSeq.isEmpty) s"\n${activeTransitions.size}:[undo]" else ""}")
  }

  private def toInt(s: String): Option[Int] = {
    try {
      Some(s.toInt)
    } catch {
      case e: Exception => None
    }
  }

  private def askToQuit: Unit = {
    println("Quit? (y/n)")
    readLine() match {
      case "y" => //Do nothing
      case "n" => askToStep
      case _ => askToQuit
    }
  }

  //Call this method to start
  def askToStep: Unit = {
    printSelection
    val readLineRes = readLine()
    //    println(s"readLineRes: $readLineRes")
    toInt(readLineRes) match {
      //One transition is selected
      case Some(i) if i >= 0 && i < activeTransitions.size => {
        previousState = Some(activeState)
        stateTransSeq = stateTransSeq :+ StateTrans(activeState, activeTransitions(i))
        askToStep
      }
      //Undo
      case Some(i) if i == activeTransitions.size && !stateTransSeq.isEmpty => {
        previousState = Some(activeState)
        stateTransSeq = stateTransSeq.init
        askToStep
      }
      //Not a correct choice
      case _ => askToQuit
    }
  }

}